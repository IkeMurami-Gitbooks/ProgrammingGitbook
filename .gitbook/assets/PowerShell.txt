# PowerShell.

# Alias - это короткое, удобное для запоминания имя, использующееся вместо более длинного и сложного имени.
# Некоторые командлеты могут вызываться с помощью алиасов:
# Пример, вместо Get-Help:    
    Help
# При написании больших скриптов или коллективной разработке можно пользоваться комментариями.
# Каждый комментарий начинается с символа #, а блок комментариев ограничивается
# комбинациями символов <# и #> в начале и в конце соответственно.

# Чтобы узнать, какая версия PowerShell установлена, нужно запустить PS (или ISE) и ввести:
    $PSVersionTable
    
# Чтобы проверить какая системная политика, ограничивающая выполнение скриптов используется:
    Get-ExecutionPolicy
# В ответ мы получим одно из след значений:
    Restricted   # — выполнение скриптов запрещено. Стандартная конфигурация;
    AllSigned    # — можно запускать скрипты, подписанные доверенным разработчиком; перед запуском скрипта PowerShell запросит у вас подтверждение;
    RemoteSigned # — можно запускать собственные скрипты или те, что подписаны доверенным разработчиком;
    Unrestricted # — можно запускать любые скрипты.

# Чтобы установить нужную:
    Set-ExecutionPolicy RemoteSigned

# При необходимости список всех доступных командлетов можно вывести с помощью:
    Get-Help
    
# У каждого командлета есть несколько параметров, определяющих его работу.
# PowerShell ISE автоматически предлагает все доступные параметры с отображением их типа. 
# Пример:
    Get-Service -Name W* # Выводит список служб, у которых имя начинается с W.

# Узнать какие параметры у введенного командлета, можно:
    Get-Member
# Пример:
    Get-Process | Get-Member

# Если всё же не нашли нужных параметров:
    -Examples
#Пример:
    get-help get-process -examples
    
# Для открытия справки по какому-либо командлету или функции в Интернете необходимо ввести следующее:
    get-help <имя_командлета> -Online
# Для получения справки по какому-либо командлету необходимо ввести следующее:
    Get-Help <имя_командлета>

# Названия разделов общих понятий начинаются с "About_".
# Для получения справочных сведений о каком-либо понятии или элементе языка необходимо ввести следующее:
    Get-Help About_<название_раздела>
# Для поиска слова или фразы в файлах справки необходимо ввести следующее:
    Get-Help <условие_поиска>
# Для получения дополнительных сведений о каомандлете Get-Help необходимо ввести следующее:
    Get-Help Get-Help -Online
    
# ПРИМЕРЫ
      Save-Help                         # : загрузка файлов справки из Интернета и сохранение их в общей папке.
      Update-Help                       # : загрузка и установка файлов справки из
                                        #   Интернета или общей папки.
      Get-Help Get-Process              # : отображение справки по командлету Get-Process.   
      Get-Help Get-Process -Online
                                        # : открытие справки по командлету Get-Process в Интернете.                            
      Help Get-Process                  # : постраничное отображение справки по командлету Get-Process.
      Get-Process -?                    # : отображение справки по командлету Get-Process.      
      Get-Help About_Modules            # : отображение справки по модулям Windows PowerShell.
      Get-Help удаленное взаимодействие # : поиск в справочных разделах по фразе "удаленное взаимодействие".

# СМ. ТАКЖЕ:
      about_Updatable_Help
      Get-Help
      Save-Help
      Update-Help
      
# Конвейер
# PS позволяет осуществлять обмен данными между командлетами с помощью конвейера.
# Пример:
    Get-Service | SortObject -property Status # сортировка запущенных служб по статусу
    "Hello World" | Out-File C:\pso\test.txt

# Важно понимать, что команды PowerShell возращают объекты.    

# Работа с файлами_________________________________:

# PowerShell предоставляет пользователям четыре способа работы с файлами:
    #    1. Применение составных команд.
    # Существует ряд команд, созданных специально для работы с файлами.
    # При помощи этих команд вы можете управлять файлами и путями к файлам так, как если бы работали с содержанием файлов.
    #    2. Применение команд DOS. PowerShell полностью совместим с командами DOS.
    # Таким образом, то, что вы можете сделать при использовании DOS, вы можете сделать и при помощи PowerShell.
    # PowerShell признает даже команду xcopy.
    #    3. Использование инструментария управления Windows Management Instrumentation (WMI).
    # WMI предлагает иной механизм для управления файлами (например, изменение файловых свойств, поиск или переименование файла).
    # Лучше всего запускать команды WMI в удаленном режиме.
    #    4. Применение методов Microsoft. NET Framework.
    # Пространство имен. NET System.IO доступно через командную строку PowerShell.
    # Эта строка включает в себя классы System.IO.File и System.IO.FileInfo.
    
# Команды для работы с файлами:
    
    Get-ChildItem # Возвращает элементы, обнаруженные в одном или нескольких указанных местах.
    # Местоположение может быть контейнером файловой системы, таким как каталог, или местом,
    # Показанным другим провайдером, таким как подраздел реестра или хранилище сертификатов.
    # Можно задействовать параметр -Recurse, чтобы добраться до элементов во всех подпапках.
    
    Get-Item      # Возвращает элементы из назначенных метоположений.
    # Как и Get-ChildItem, Get-Item может применяться для навигации по зазличным типам хранилищ данных.
    # В отличие от Get-ChildItem, Get-Item не имеет местоположения по умолчанию, поэтому вы должны всегда предоставлять,
    # как минимум, одно местоположение с помощью параметра -Path.
    # Хотя сам параметр и нужнен, указывать имя параметра не требуется.
    # Команда Get-Item возращает объекты System.IO.DirectoryInfo, которые содержат несколько методов и свойств.
        Get-Item . | Get-Member -MemberType Property
        # Посмотреть методы и свойства можно так, передав результаты команды Get-Item.
    
    Copy-Item # Является реализацией в PowerShell команды copy bp DOS и команды cp из UNIX.
    #** Псевдонимы: copy, cp, cpi
    # Copy-Item сконструирован для работы с данными, выдаваемыми любым провайдером.
    # Первыми двумя параметрами команды являются -Path (вы используете его для указания элемента,
    # который хотите скопировать) и –Destination (вы применяете его для указания места,
    # в которое хотите скопировать этот элемент).
    # Они позиционные, поэтому имена параметров можно опустить.
    # Чтобы получить более детальное управление операцией копирования, можно задействовать параметры -Recurse, -Filter и –Force.
    
    Move-Item # Move-Item очень похожа на Copy-Item.
    #** Псевдонимы: move, mv и mi
    # Главных два отличия в том, что файлы при копированни удаляются из исходной папки.
    # И если вы запустите одну и ту же команду Copy-Item дважды, то обнаружите,
    # что PowerShell переписывает существующий файл в папку назначения без какого-либо предупреждения.
    # Move-Item более осторожна в этом смысле и вместо удаления выдает ошибку. Это и есть второе важное отличие.
    
    New-Item # New-Item играет двойную роль — создателя каталога и файла (кроме того, она может создавать разделы и параметры реестра).
    #** Псевдонимы: ni
    # Когда хотим создать файл, нужно указать параметры –Path и –ItemType.
    # Сам -Path можно опустить, а вот значение его нужно указать, а также нужно указать параметр -ItemType при помощи флажка "file"
    # Параметр –Path может принимать массив строк так, что мы можем создавать несколько файлов за раз.
    # Нужно просто разделить пути при помощи запятых.
    # Вдобавок, необходимо вставить сначала параметр -ItemType "file", который означает, что вам нужно указать имя параметра –Path,
    # поскольку он теперь не первый параметр после имени команды.
        New-Item -ItemType "file" -Path "C:\Temp\test.txt", `
        "C:\Documents and Settings\Nate\file.txt", `
        "C:\Test\Logs\test.log"
    # Если файл с точно таким же именем пути файла уже существует, вы получите ошибку.
    # Однако вы можете указать параметр:
        –Force # так, что New-Item перепишет существующий файл.
    # Что на самом деле примечательно, так это то, что New-Item позволяет вставлять текст в файл посредством параметра –Value:
        New-Item 'C:\Documents and Settings\Nate\file.txt' `
        -ItemType "file" -Force `
        -Value "Here is some text for my new file."
    # Параметр –Value может принимать ввод данных по конвейеру, что является отличным способом перенаправлять вывод данных других команд в файл.
    # Нужно выполнять конвертацию выходных объектов в строку, используя Out-String
    # Если этого не делать, New-Item создаст новый файл для каждого объекта.
    # Следующей командой мы возвращаем информацию обо всех файлах из корневого каталога C,
    # затем конвертируем информацию о файлах в строку и пишем эту инфу в файл H:\C Listing.txt:
        Get-ChildItem C:\* | Out-String |
        New-Item -Path "H:\C Listing.txt" -ItemType "file" -Force
    
    Remove-Item # ...
    
    Rename-Item # ...

# Примеры использования:
    
    #__ Использование Get-ChildItem:
    # Получаем список объектов с расширением *.log рекурсивно и включая скрытые файлы.
    Get-ChildItem C:\* -Include *.log -Recurse - Force
        -Include # Возвращение заданных элементов.
        # Он поддерживает использование групповых символов и является идеальным для указания расширения имени файла.
        -Recurse # Дает указание возвращать подпапки наряду с файлами.
        -Force   # Добавляет скрытые и системные файлы к выходным данным. 
    
    #__ Использование Copy-Item:
    # Копирование файла test.txt (команды равносильны):
    Copy-Item C:\Scripts\test.txt C:\Backups\Scripts
    Copy-Item -Path C:\Scripts\test.txt -Destination C:\Backups\Scripts
    #__ Копировать все файлы по указанному пути:
    Copy-Item C:\Scripts\* C:\Backups\Scripts
    #__ Копировать все файлы *.txt содержащиеся в C:\Scripts в C:\Temp\Text:
    Copy-Item -Path C:\Scripts -Filter *.txt -Recurse `
    -Destination C:\Temp\Text
    # НУЖНО обратить внимание, что символ обратной одинароной ковычки стоит в конце первой строки.
    # Это означает в PS продолжение строки.
    
    #__ Использование Move-Item:
    Move-Item C:\Scripts -Filter *.txt -Recurse `
    -Destination C:\Temp\Text
    
    #__ Использование New-Item:
    New-Item -ItemType "file" -Path "E:\PowerShell\TempFile\OxyForensicCloudExpert\test.txt"
    New-Item "E:\PowerShell\TempFile\OxyForensicCloudExpert\test.txt" -ItemType "file" -Force -Value "Текст который теперь в файле"
    
    

# Дополнительно:
# Командлеты в оригинальной нотации PS имеют следующую систему именования - Глагол-Объект.
# Это позволяет лучше понимать, что можно ожидать в результате выполнения того или иного командлета:
# Пример:
    Get-Process # Получить список процессов запущенных на компьютере
    Get-Service # Получить список служб и их статус
    Get-Content # Получить содержимое указанного файла, например Get-Content C:\Windows\System32\drivers\etc\hosts
    Remove-Item # Удалить что-то
    Get-Help    # Получить справку по чему-то
    Set-Alias   # Создать новый алиас
    New-Item    # Создать новый объект (объектом может быть всё что угодно, например, файл)
    Get-PSDrive # Что за диски находятся системе?    
# Командлеты (команды встроенные в сам PS) в PowerShell:
    dir # (или ls) - получаем список папок в текущем каталоге
    ls  # Alias:\  - получаем список всех алиасов

# Что-то:    
    Get-Item $PathMain | Where-Object{$_.PSIsContainer}

# На диске Alias можно увидеть список всех алиасов в системе.
# Витруальный диск Variable хранит в себе все переменные, которые можно использовать в данной сессии.

    (Get-WmiObject Win32_OptionalFeature).Name # получить список features windows 10
     Get-WmiObject Win32_OptionalFeature       # получить список features windows 7
     
# Если вы хотите посмотреть, как выглядит цифровая подпись, запустите в Windows PowerShell команду:
    type $pshome/types.ps1xml # Информация в самом конце файла и будет являться цифровой подписью.
# Проверить статус цифровой подписи файла можно с помощью команды:
    get-authenticodesignature $pshome/types.ps1xml
    
# Также вы можете сгенерировать сертификат локально с помощью инструмента MakeCert.exe,
# который является частью Windows Platform SDK.
# Чтобы узнать о MakeCert.exe и о том, как им пользоваться, запустите в Windows PowerShell команду:
    Help about_signing 
# Локальный сертификат может использоваться только на данном локальном компьютере.
# Скрипты, подписанные с помощью этого сертификата, могут выполняться только на этом компьютере. 
# После того, как вы установили сертификат, вам необходимо запустить командлет Set-AuthenticodeSignature,
# чтобы прикрепить подпись к сценарию. Раздел справочника, посвященный этому командлету,
# содержит описание деталей его использования и примеры. 
# Прочитайте справочные материалы по Set-AuthenticodeSignature и изучите некоторые его опции.
# Придумайте несколько примеров того, как можно использовать его для создания подписи к скрипту.

# Когда вы запускаете параметризированный сценарий, вы можете разместить параметры либо позиционно,
# либо используя имена. Если скрипт под названием MyScript.ps1 содержит блок параметров:
    Param($computerName, $userName)
# То вы можете запустить команду: 
    ./myscript 'localhost' 'Administrator' 
# или такую (более легкую для чтения): 
    ./myscript –computerName 'localhost' –username 'Administrator'
    
# А так можно запросить параметр у пользователя:
    Param($computerName = $(Read-Host 'Enter computer name'), $userName = $(Read-Host 'Enter user name'))
    
# Генерить GUID можно так:
    # Create an empty GUID
    $Id = [GUID]::Empty
    # Create a new GUID
    $Id = [GUID]::NewGuid()
    $Id.ToString().ToUpper()
    $Id.Guid.ToString().ToUpper()
    # Create a GUID with a value
    $Id = [GUID]("b2e92f11-7f65-41d1-acec-ba051b418bdf")
    # Ещё варианты:
    $Id = [System.Guid]::NewGuid().ToString().ToUpper() # получаем сразу строку в Upper регистре
    $Id = [Guid]::NewGuid().ToString().ToUpper()        # получаем сразу строку в Upper регистре
    
# Работа с путями:
    if ((Test-Path "E:\PowerShell") -eq $true) {
        # тут выполняем действия
    }
    else {
        # тут другие действия
    }
    
# Проверка на сущестования файла:
    if ([System.IO.File]::Exists($Path)) { Write-Host "yes"} else { Write-Host "no"}
# Проверка на несуществование файла:    
    if (![System.IO.File]::Exists($Path)) { Write-Host "yes"} else { Write-Host "no"}